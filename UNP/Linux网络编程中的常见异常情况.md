# Linux网络编程中的常见异常情况

## 概述

在Linux网络编程中，当只考虑正常情况时，使用套接字（socket）进行TCP和UDP编程是非常方便的，我们可以使用仅仅5到6个API就创建一个简单的TCP客户端或者服务器。但是由于C语言进行套接口编程时，接近操作系统内核，没有例如Java、Python等语言良好的网络套接字封装，导致我们在编程时必须考虑很多其它高层次语言不需要考虑的细节。本文对我们在网络编程中常见的异常情况进行归纳和讨论，争取涵盖尽量多的方面。

## 通信异常

### 概述

本小节主要讨论TCP协议中通信两端可能出现的异常情况，包括客户端中断连接、客户端崩溃、服务器中断连接、服务器崩溃。

这里我们需要区分一下“中断”和“崩溃”两个词的区别。“中断”意味着通信双方任意一端主动或被动发送了FIN分节，导致网络通信中断，这种中断可以是在双方期望的情况下发生的（也就是正常终止），也可能是由于其中一方由于错误导致程序退出，内核协议栈发送了双方不期望的FIN分节。而“崩溃”则完全不同，“崩溃”意味着其中一方的主机发生了灾难性的错误，导致直接关机。在这种情况下，崩溃的一方将不能发送任何信息给对端（比如FIN分节），对端需要在接收不到任何消息的情况下对这种错误进行处理，我们通常会采用为套接字设置超时，这种方法会在下文进行详细讨论。

### 客户端中断连接

正常情况下，客户端在发送完全部数据后中断连接通常不会有任何问题（如果你的客户端仅仅是单纯的发送数据！）。但是我们需要在这里讨论一个细节：由于网络延迟的原因，如果客户端完成数据传送后直接关闭连接，而此时有一些服务器发送回的数据正在传输途中，这会导致客户端接收不到这些本该收到的数据，且服务器可能会收到预期之外的RST分节（访问了没有被监听的端口）。

发生这种错误的原因是，调用`close`函数来关闭连接时，会同时关闭TCP的读端和写端（相当于意外的关闭了接收端的连接）。为了解决我们这个问题，我们应当在客户端完成写端（发送数据）的任务后，调用：

```c
shutdown(int sockfd, int howto)
```

`shutdown`函数可以根据`howto`参数来选择关闭套接字的读端或写端。当关闭读端（接收数据）时，指定`howto`为`SHUT_RD`；关闭写端（发送数据）时，指定`howto`为`SHUT_WR`。你也可以指定`howto`为`SHUT_RDWR`，同时关闭读端和写端。

那么，对于我们之前讨论的情形，显然客户端应该在发送完需要发送的数据后，使用`shutdown(sockfd, SHUT_WR)`来通知服务器——客户端已经完成了所有的数据发送，但是依然可以接收服务器发送的后续数据（比如数据处理结果等）。

### 客户端崩溃和服务器崩溃

TCP任意一端的崩溃，都会导致另一端接收不到任何分节。而程序将会一直阻塞于IO调用，直到协议栈的重传机制最终因超时产生错误，才会向用户空间传递该错误（`ETIMEOUT`或`EHOSTUNREACH`或`ENETUNREACH`，后两个错误是由于中间路由器节点发现该崩溃并由ICMP报文传回），而这通常会花费数分钟的时间。

为了避免这种不必要的长时间等待，我们应当为通过`setsockopt`函数为套接字设置`SO_RCVTIMEO`和`SO_SNDTIMEO`选项，这两个选项指明了套接字的接收超时时间和发送超时时间。

我们也可以使用`SO_KEEPALIVE`来在TCP层建立心跳线，以检测对端是否存活。

### 服务器中断连接

当服务器处理当前客户端请求的线程意外终止时，服务器将会释放当前占用的端口。这里有一个非常有意思的现象——如果客户端继续向该连接写入数据（比如此时客户端正阻塞于其它系统调用，并没有接收到这个错误），将会收到一个RST分节，而IO调用将会返回一个错误，并设置`errno`为`ECONNRESET`；然后，如果我们继续写入数据，程序将会收到系统发来的`SIGPIPE`信号，IO调用返回`EPIPE`错误，而`SIGPIPE`信号的缺省操作是终止程序。这一行为的解释是：向一个已经接受了FIN分节的连接写入数据是没有问题的（写入后接收RST），这正是TIME_WAIT存在的意义；但如果向一个已经接收RST分节的连接写入数据，则是一个完全的错误。

检测连接的中断是非常简单的，如果一个套接字接收了FIN分节，它将立刻处于可读可写的状态（为了方便下一个IO操作尽快获取到这个事件），对它的读操作（`read`、`recv`等 ）将会立刻返回0，即没有读取到任何数据；而对于写操作，则会产生非致命错误`ECONNRESET`。另外，IO复用函数（`select`，`poll`等）也能及时检测到这一可读可写状态。

## 数据异常

### 发送二进制数据

在发送二进制数据时，一定要注意数据的大小端问题。除非你能确保程序的运行环境一定是在同样字节序的机器上，否则通用的做法是通过约定或应用层协议，规定字段的字节序。对于字符数据，则不存在这个问题。