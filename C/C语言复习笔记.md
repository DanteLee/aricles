# C语言复习笔记

## C语言编译流程

预处理->编译->汇编->链接->生成可执行程序

预处理主要是对源程序进行文本性质的操作，例如进行宏命令替换等；

编译主要是将源文件进行词法、语法分析，并进行一系列优化操作生成汇编代码，绝大多数的告警信息产生于这个阶段；

汇编是将前一阶段产生的汇编文件编译为目标文件，即被机器执行的机器码；

链接则是将多个存在调用关系的目标文件连接为一个可执行程序，这个阶段主要是为了解决各种符号和库函数调用。

```shell
# 产生预处理文件，后缀名为.i
gcc -E target.c
# 产生汇编代码，后缀名为.s
gcc -S target.i
# 产生目标代码，后缀名为.o
gcc -c target.c
# 产生指定文件名的可执行程序
gcc -o target target.c
# 优化，等级可以选择1~3，等级越高编译时间越长
gcc -O1 target.c
```

## C语言基本数据类型

C语言一共包含4中基本数据类型：整型、浮点型、指针和聚合类型。

### 整型

定义形式可以被归纳为：`[符号修饰][长度修饰][int]`

符号修饰：有`signed`和`unsigned`两种形式，分别代表有符号数和无符号数，当不直接指定时，`signed`是默认值

长度修饰：有`long`和`short`以及为空三种不同取值，每一种取值在不同的机器和操作系统上有不同的长度定义

int：当长度修饰出现时，可以省略不写

```c
signed long int;
unsigned short;
unsigned int;
long;
short int;
int;
```

另外，整型可以有多种不同进制的表达形式：

```c
// 八进制
// 开头为0
0177;

// 十进制
1239;

// 十六进制 
0x12af
  
// 字符本身也是一个整数
'a';

// 宽字符集
// 以L开头
L'X'
```

还有一种枚举类型，也是整型的一种：

```c
enum day {Sun, Mon, Tue, Wed, Thursday, Friday, Sat}
// Myday可以取值为上面枚举类型中的任意一个
day Myday = Sun;
// he=1, she=4, him=5
enum person {he = 1, she = 4, him}
```

枚举类型类似与宏命令的`#define`，但是宏命令本质上是字符上的替换，而枚举则是C定义的一种数据类型。在枚举类型中，每一个符号名都是一个整数，默认从0开始依次增长，但也可以为它们赋初始值。

### 浮点型

浮点型在计算机中的存储形式如下：

`[阶符:1bit][阶码][数符:1bit][尾数]`

例如2进制数`(1011.011)`表示为`2^(100)*（0.1011011)`，其中`(100)`为阶码，`(1011011)`为尾数

### 指针

指针实际上也是一个正数，但是这个整数将直接指向一个真实的物理地址，这是非常强大也非常危险的功能，因此被单独作为一个类型。它的长度取决于你所使用的机器的寻址总线宽度，例如你是64位的计算机，那么在你的系统中，指针变量的长度即为64 bit（这需要你使用的操作系统也支持64位寻址）。

要声明一个指针类型非常简单，只要在声明一个变量时，在这个变量名之前加上一个`*`即可：

```c
int *a;
char *a;
// 下面这种声明形式只声明了a这一个指针变量
int* a, b, c;
```

### 聚合类型

主要包括：数组、结构体、联合体

#### 结构体

```c
struct struct_t {
  int a;
  char b;
}

struct struct_t mystruct;
mystruct.a = 4;
```

结构体还有一种位段的用法：

```c
struct bit_t {
  unsigned first :6;
  unsigned second:6;
  unsigned third :3;
}

struct bit_t mybit;
// 6 bit long
mybit.first = 0x24;
```

位段可以直接指定该成员的长度，单位为`bit`

**注意**：两个具有相同类型的结构体是可以直接进行赋值操作的，比如：

```c
struct type a;
struct type b;
// 下列语句合法
a = b;
```



####  联合体

```c
union union_t {
  int a;
  long b;
  int *c;
}

union union_t demo; 
```

联合体的使用方式与结构体类似，比较特殊的一点是，联合体在同一时间内只能是成员类型中的一个，即同一时间内联合体只存储一个成员变量的值。事实上联合体并没有存储所有成员的空间，它的长度取决于成员中最长的那一个。例如在上例中，我们赋值`demo.c = ptr`，假设我们使用32位的操作系统，`int`长度为16位，那么此时`demo.a`的值就是`demo.c`的低16位。

#### 数组

```c
// 未指定初值的，默认被初始化为0
int a[10] = {1,2,3}

// 初始化字符数组
char b[10] = "hellow C"
```

注意，在初始化字符数组的时候，并不是将一个字符串常量赋值给了数组，这其实是初始化器的特殊写法，字符数组中的字符是可以被修改的。

数组名本身是一个指针常量（跟指针变量相区分），如下所示：

```c
int a[10];
int *p;

// 下面的赋值是正确的
p = a;
// 下面的赋值是错误的，因为a是一个常量
a = p
```

同时，下面两种写法也是等价的：

```c
a[2] == *(a+2)
```

对于多维数组（以2维数组为例），其第一维是一个指针常量数组（指向其他数组）：

```c
int a[2][3] = {
  {1,2,3},
  {4,5,6}
};

// 第一个数组的起始地址
&a[0][0] == a[0];
// 第二个数组的起始地址
&a[1][0] == a[1];
// 访问二维数组中的值
a[1][2] == *(*(a+1)+2)
```

从上例的最后一个可以看出，二维数组的第一维实际上是一组指向数组的指针。

**注意**：二重指针和指向数组的指针是完全不同的，对于上例中的`(a+1)`操作，必须知道第二维的数组长度为多少才能实现步进。最典型的例子如下：

```c
int a[2][10];

// 多维数组必须指定除第一维之外每一维的长度，以便实现步进*(a+1)
int function(int a[][10]);
// 这样的声明中，a是不能被传入的
int function(int **a);
```

我们可以这样定义指向数组的指针：

```c
// 一个指向长度为10的数组的指针
int (*a)[10];

// 因此上例中的函数也可以这样声明
int function(int (*a)[10]);
```

## 语句

C语言控制语句包含循环和分支两大类，`break`语句可以用来跳出当前循环体

### 循环

#### `while`循环

基本语法：

```c
while (expression) {
  // statements
}
```

当expression值为真时，执行循环体，先判断条件，再执行循环体。

expression可以为任意合法的C表达式。

#### `do`循环

基本语法：

```c
do {
  // statement
} while (expression)
```

执行完循环体之后，判断expression的值，再决定是否继续循环

#### `for`循环

基本语法：

```c
for (initial; expression; step) {
  // statement
}
```

for循环非常的灵活，initial expression step三者均是可选的。

initial是初始化语句，只在循环体执行前运行一次，可以初始化不止一个变量，多个变量的初始化用`,`隔开：

```c
for (i = 0, j = 1; i < 1000; j++) {
  i++;
}
```

expression可以是任意合法的C表达式，当expression的值被评估为假时，退出循环

step同行被用与循环的步进操作，这个步进操作总是在循环体被执行一次后再被执行，但是要注意，下列两种写法具有相同的效果：

```c
for (i = 0; i < 100; i++);
for (i = 0; i < 100; ++i);
```

### 分支

#### `if`语句

基本语法：

```c
if (expression) {
  // statements
} else {
  // statements
}
```

`else`语句是可选的，同时`if`语句可以嵌套使用

####  `switch`语句

基本语法：

```c
switch (expression) {
  case integer:
    // statements
    break;
  case character:
    // statements
    break;
  default:
    // statements
}
```

`switch`用于在多个分支中选择一个分支进行执行。

expression可以是任意C语言表达式，但是这个表达式的值必须是一个整数类型。`switch`语句会将expression的值与每一个`case`分句后面的值进行比较，若相等，则执行该分支。如果所有的分支都不匹配，则执行`default`分支下的语句。

`break`语句不是必需的，但是若不在每个分支后都加上`break`，则会产生一种“贯通”的效果。即该分支的下一个分支语句也会被执行

#### `goto`语句

基本语法：

```c
int expression = 1;

// goto 语句可以让程序立即跳转到指定的“符号标记”处执行
if (expression == 1) goto true_label;
else goto false_label;

// 指定符号
true_label:
printf("==1");
goto exit_label;

false_label:
printf("!=1");

exit_label:
return 0;

// 上述语句等价于
if (expression == 1) {
  printf("==1");
} else {
  printf("!=1");
}
return 0;
```

不建议在程序中使用goto语句

## 操作符和表达式

### 操作符

操作符主要分为：一元操作符、二元操作符、三元操作符。常见的操作符将不在赘述。

#### 位操作符

主要有左移`<<`、右移`>>`，与`&`、或`|`、异或`^`、取反`~`

需要注意的是，取反是一元操作符

#### 自增/减操作符

自增/减操作符的特殊之处，在于当它作为表达式时，取值方式跟其作为前缀还是后缀有关。

```c
int i = 1;

// 输出1
printf("%d", i++);

int i = 1;
// 输出2
printf("%d", ++i);
```

#### 逗号`,`操作符

逗号操作符的作用在于连接多个表达式成为一个表达式，这个表达式的值取决于最右端的表达式的值

```c
// 该表达式值为true
f = 2, i = 8, f > 0;

for (; i = 0, i < 100; i++);
```

#### 逻辑操作符

逻辑操作符包括`> < >= <= == ! || &&`。

**注意**：在`C11`标准中，这些逻辑表达式也具有返回值。

### 表达式

表达式一般分为两种类型，左值表达式（lexp）和右值表达式（rexp）。所谓左值表达式，是指出现在赋值语句左侧的表达式，同理可得右值表达式的定义。右值表达式是不可以出现在赋值语句的左侧的。一种通俗的理解是，左值表达式是代表一个计算存储器中的位置，而右值表达式则是一个可以被计算机理解的值（位置本身也是一个值，所以它可以出现在赋值语句右侧）；

#### 一些特殊表达式的返回值

```c
// 返回值是最右侧的子表达式的值（c的值）
(a, b, c);

// 逻辑表达式的返回值，当结果为真时，返回1，否则返回0
// c = 1
c = (a == b);

// 赋值表达式的返回值是其左值的最终值
// a b 均为2
a = b = 2;
int a;
float b;
// a = 4, b = 5
a = b = 4.5;

// 一些组合性的例子
// a = 1
a = (b = 2, c = 4.5, b < c);
```



## 函数

函数分为声明和定义两种形式，声明的作用在于表示该函数的存在，而定义则是该函数的具体实现。

声明和定义可以不在同一个文件之中。

### 声明

```c
type function_name (argType argument);
```

### 定义

```c
type function_name (argumentList) {
  // statement
}
```

### 调用

```c
function_name(arg1);
```

## 常量

常量通常用于修饰一个声明：

```c
// 变量a是不能被修改的，因此必须进行初始化
const int a = 10;
```

对于指针，常量修饰符的使用稍微有点不同：

```c
// a指向一个常量整数
const int *a = 10;
// a指向一个可变的整数，但是a本身所存储的地址（即其值）不能被修改
int * const a = (int *)malloc(sizeof(int));
```

## `sizeof`

`sizeof`本身是C语言中的一个一元运算符，但是某些编译器也将它定义为宏。`sizeof`作用于不同的对象时，将返回不同的值

1. 当`sizeof`作用于数据类型名，如`sizeof(int)`时，将会返回这个类型所占用的字节数
2. 当`sizeof`作用于一个变量时，会返回对应类型的所占用的字节数
3. 当`sizeof`作用于指针时，会返回指针的长度，比如在32位计算机中，返回4
4. 当`sizeof`作用于数组时，会返回数组的长度
5. 当`sizeof`作用于字符串时，会将它转化为数组并返回其长度，包括`\0`字符
6. 当`sizeof`作用于结构体时，返回整个结构体所占字节数
7. 当`sizeof`作用于联合体时，返回联合体中最大的成员所占的字节数

## `typedef`

`typedef`操作符用于定义一种类型的别名：

```c
typedef int[10] array10;

// 声明一个长度为10的整型数组
array10 arr;
```



## 作用域

作用域我们把他分为以下几类：

1. 代码块作用域
2. 文件作用域
3. 原型作用域
4. 函数作用域

### 代码块作用域

在C语言中，每一对花括号被称作一个块级作用域，块级作用域可以嵌套，内层可以访问外层作用域中的变量，而外层作用域不能访问内层中的变量：

```c
int a = 1, b = 2;
{
  int a = 2;
  // 输出2
  printf("%d", a);
}
// 输出1
printf("%d", a);
```

### 文件作用域

每一个C语言源文件都是一个独立的作用域，除非被其它文件所引用（通过include的方式），否则其内部声明的变量不能被其它文件访问到。

文件作用域共有三种属性`internal`、`external`和`none`，我们暂且不理会`none`属性，先讨论另外两个。

当一个变量被声明为`internal`属性时，它将不能被所在源文件以外的地方访问到。我们把每一个源文件视为一个模块，那么声明为`internal`的变量将会对外隐藏。声明方式如下：

```c
// internal variable
// 注意，这与在函数中使用static变量不同，这里是对全局变量的修饰
static int a;
```

当一个变量被声明为`external`属性时，它将可以被其它源文件所访问，类似与模块对外提供的接口。凡是没有被声明为`internal`属性的变量均具有`external`属性。

```c
// mylib.h
// 这是一个定义
int a = 10;

// mylib2.c
#include <mylib.h>
// 这是一个声明，a只在mylib.h中被定义了一次，且初值为10
extern int a;
// 输出10
printf("%d", a);
```



### 原型作用域

在声明函数原型时，形参名并没有约束力，甚至可以不写：

```c
// 下述声明是一种合法声明
int function(int *, int *);

int function(int *a, int *b) {
  // statement
}
```

### 函数作用域

跟`goto`语句相关，永远不要用到它







