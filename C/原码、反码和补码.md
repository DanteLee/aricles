# 原码、反码和补码

## 转换关系

若原码为负数：补码 = ~原码 +１ = 反码 + 1

若原码为正数：补码 = 原码

注意，取反码时不能对符号位取反

## 何为补码

在理解补码之前，应当理解“模”的概念。

模本身也是一个数字，但是这个数字本身在所属的计量系统中是无法表示的（这是由于计算机中数字以0为起点）。以时钟为例，它的表示范围为0~11（12点表示为0点），那么在时钟的计量系统中模就是12。12本身无法在这个系统中得到表示，但是它限制其中所有的值都无法大于等于这个值。

现在有一个指向10点的时钟，我们想要把它调整至6点有两个办法，一个是向回调整4个小时（减4），或者向前拨快8个小时（加8，(10+8) mod 12 = 6）。可以看到，在模为12的系统中，加8和减4实际上得到了相同的效果，同样，加11和减1，加10和减2也具有相同的效果。我们把(8, 4)这样和为“模”本身的数对称为“互为补数”。

在计算机系统中，补码的正数表示是和原码保持一致的，但是负数的补码表示则遵循前述转换规则。

## 为什么要引入补码

首先，引入了补码实际上统一了加法和减法系统，因为在补码系统中，减法可以被对应减数补码的加法运算（如上例中加8和减4具有相同的效果）所替代，减少了硬件运算电路。

其次，补码统一了运算符域和运算数域。在计算机中，所有数字表示都被分为符号位和运算数两部分，例如在一个8 bit计算机中，一个有符号数最多只能表示为-128~127这么大，这是因为最高的一位被作为符号位（1代表负数，0代表正数），只有剩下7个bit被用于数字表示（但是无符号数则可以表示为0~255）。

若是所有的运算使用原码，那我们不得不使用额外的电路来判断符号位。但使用补码，则无需判断符号位，直接进行相加运算即可，无需对运算符进行额外判断。例如计算（-1-2），即(10000001)-(10000010)，使用原码时，我们必须先对符号位进行判断，然后把绝对值相加，再补上符号位，这样的运算在加减混合时，复杂度会更高。但若是使用补码，上述运算就会变成(11111111)+(11111110)，直接使用加法电路进行运算，得到结果(11111101)=(-3)。可以看到，引入补码，极大简化了加减运算所需的电路复杂度。

另外，补码和原码的相互转化使用同样的方式，因此只用同一种电路就可以实现原码和补码的相互转化。

## 补码的特性

1. 互为补数的两个数相加等于模
2. 正数的补码与原码相同
3. 负数的补码，其实是对应正数部分不断减小的过程。例如8 bit计算机中，-1到-128的表示实际上是(11111111)=(-1)，(11111110)=(-2)，(11111101)=(-3)，...，(10000000)=(-128)的变化过程
4. 在补码系统中0只有一种表示方法即(00000000)，而在原码和反码系统中会有两种0，即(1000000)和(00000000)