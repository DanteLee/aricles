# Linux中的进程

> 本文从Linux内核的角度来阐述Linux操作系统是如何管理进程的整个生命周期的

## 什么是进程

进程实际上就是处于执行期间的程序（通常情况下我们将编译出来的可执行文件称为程序），它包含了一切运行该程序所需要的资源，包括：代码段、打开的文件描述符、处理器状态、挂起信号、内核内部数据、内存地址空间、页表项等。在《Linux Kernel Development》一书中有一个非常精彩的描述——”实际上，进程就是正在执行的程序代码的实时结果“。

提到了进程，就不得不引出另一个息息相关的概念——线程。一个进程中可以包含若干的线程，这些线程共享进程所持有的一切资源，包括：锁，文件描述符，全局变量，内存地址空间等；各个线程相互独立的执行。因此许多现在操作系统相关的书籍，在讲到进程和线程的关系时，大多都提到一句话：”进程是操作系统进行资源调度的基本单位，而线程则是操作系统执行的基本单位“。在Windows操作系统中，进程和线程是两个完全不同的概念，创建进程和线程也使用完全不同的API而且创建线程的速度也比远比创建进程更快。但是在Linux操作系统中，内核不对线程和进程进行区分，它们使用相同的结构进行描述，完全平等的被内核调度。事实上，Linux操作系统只是把线程看作是一些相互共享资源（地址空间、文件描述符等）的进程，创建线程和进程所使用的API也是完全一样的。

> 总结一句话，Linux中只有进程一种概念，通过进程之间共享资源来实现跟线程同样的效果。

## 如何描述进程

在Linux操作系统中，我们使用`task_struct`结构来描述进程，也就是我们常说的进程描述符，在这个结构中包含了描述一个进程所需要的*通用*的信息（比如进程的唯一标识符PID）。但是对于不同的计算机体系结构，描述一个进程可能还需要一些额外的信息，因此为了统一这些差异，Linux在`task_struct`的基础上包装了一个`thread_info`结构：

```c
struct thread_info {  
    struct task_struct  *task;      /* main task structure */  
    __u32           flags;      /* low level flags */  
    __u32           status;     /* thread synchronous flags */  
    __u32           cpu;        /* current CPU */  
    mm_segment_t        addr_limit;  
    unsigned int        sig_on_uaccess_error:1;  
    unsigned int        uaccess_err:1;  /* uaccess failed */  
}; 
```

 鉴于其存储内容的重要性，访问进程描述符的操作必然十分频繁，为了简化和加快这一步骤，Linux将`thread_info`放置于内核栈的底部（对于向下增长的栈）或顶部（对于向上增长的栈）。其存放结构类似于这样：

```c
union thread_union
{
    struct thread_info thread_info;
    unsigned long stack[THREAD_SIZE/sizeof(long)];
};
```

> 内核为每个进程在内核空间都分配了一个内核栈，这个栈不同于进程在用户空间的栈拥有超大空间，内核栈在32位的系统中一般为4KB或8KB，在64位的操作系统中为16KB。

而在实际的开发过程中，内核提供了`current`宏来访问当前进程上下文所属的`task_struct`。这个宏的具体实现和系统体系直接相关，比如在寄存器较少的x86架构中，这个宏通过屏蔽内核栈基值的后13位（8K内核栈）来获取`task_struct`。而在PowerPC中，由于寄存器较多，内核开发者专门使用一个寄存器来存储该地址；因此`current`宏仅仅简单返回该寄存器的值。

与绝大多数操作系统一样，Linux操作系统采用树状结构来组织所有进程。通过`fork`和`clone`函数，每个进程都可以派生自己的子进程，从而产生一个典型的树状结构，因此我们可以通过树的父子关系从任一节点出发访问到任意进程。顺带一提，Linux操作系统中存在一个特殊的init进程（PID为0），这个进程是系统启动过程中的第一个进程，所有的进程都由它派生，是进程树的根节点。

## 进程的创建

### 创建过程

在Linux操作系统中，进程的创建非常的与众不同。在其它操作系统中，通常有一个机制来产生（spawn）新的进程：首先创建地址空间，然后载入可执行程序，最后开始执行。但是Linux将新进程的创建分为两个步骤来完成，也就是我们常见的两个API：`fork`和`exec函数族`。我们需要有一个已经在运行中的进程，然后通过`fork`函数来派生一个子进程，紧接着我们在子进程中调用`exec`函数族将子进程“替换”为新的映像（载入新的可执行文件）。

### fork函数和exec函数族

`fork`函数用于为当前进程派生一个新的子进程，子进程将会拥有一份父进程的地址空间拷贝，这意味着子进程除了pid与父进程有区别之外，与父进程几乎一致。然后`fork`函数在父进程和子进程里分别返回子进程pid和0，使得新的进程能够识别自己的身份。`fork`函数实际上调用了系统调用`clone`，我们将在下文详细叙述`clone`系统调用。

`exec`函数族用与将当前进程的地址空间替换为指定的可执行文件映像。该函数族一共有5个函数，但是只有`execve`函数是系统调用，其他4个函数只是glibc提供的封装函数。

关于这两个函数更详细的叙述请参考这两篇文章：[fork函数](./fork函数.md)和[exec函数族](./exec函数族.md)。

### vfork函数

提到`vfork`，就不得不提到Linux在进程创建过程中所做的优化。总所周知，Linux系统一直以进程的创建迅速而闻名，这当然与较小的进程描述符（大约只有1.7k）有关，同时，这也与创建过程的优化是密不可分的。

一个著名的优化就是`fork`函数的“写时拷贝”。我们知道，`fork`函数将会对父进程的地址空间进行拷贝，包括地址空间页表、各类全局变量、临时变量、代码段等，使得子进程与拥有父进程完全一样的状态。但是如果子进程在产生后，立刻就调用`exec`函数，那么之前所做的一切工作就都前功尽弃了（拷贝地址空间的消耗非常大，因为一个进程的地址空间可能会达到几十上百M）。所谓“写时拷贝”就是在创建子进程的时候，暂不拷贝父进程的地址空间，而是让父子进程共用相同的地址空间，只有当子进程尝试向地址空间写入数据时，才拷贝数据。

再来说说`vfork`函数，`vfork`函数完成的功能与`fork`几乎完全一致，唯一的区别就是就是是否拷贝父进程的页表项。但是通常情况下我们最好不要调用`vfork`函数，而且许多系统也只是简单的将它实现为了`fork`。当将来的内核拥有了“写时拷贝页表项”功能时，`vfork`函数也就彻底失去了意义。

### clone函数和线程

前面我们说道，在Linux操作系统中，线程和进程几乎没有别区别对待。产生进程和线程的方式几乎一致，只不过产生进程，我们可以像这样调用：

```c
fork();
vfork();
```

而产生线程时，我们使用的是`clone`系统调用：

```c
clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)
```

`clone`函数的第一个参数用以指定父子进程之间将会共享的资源。

上面的例子产生了一个和原进程共享地址空间、文件系统资源、文件描述符和信号处理程序的子进程，我们通常把这种进程称之为线程。事实上，`fork`函数也是通过`clone`函数实现的。

`fork`的实现：`clone(SIGCHLD, 0)`。

`vfork`的实现：`clone(CLONE_VFORK | CLONE_VM | SIGCHLD)`。

## 进程的运行

### 进程运行的五个状态

进程描述符中的`state`字段描述了进程当前所处的状态

| 状态名                 | 解释                       |
| ------------------- | ------------------------ |
| TASK_RUNNING        | 进程可执行或正在执行               |
| TASK_INTERUPTIBLE   | 进程正在睡眠并等待一些事件，但是可被信号提前唤醒 |
| TASK_UNINTERUPTIBLE | 进程正在睡眠并等待一些事件，但是不可被提前唤醒  |
| __TASK_TRACED       | 进程正在被其它进程跟踪              |
| __TASK_STOPPED      | 进程处在不能被执行的状态             |

### 进程的运行上下文

进程的运行上下文（简称进程上下文）是指当前运行代码的运行环境，处于进程上下文意味着current宏可以被访问。进程在运行过程中，能够处于用户态和内核态中的其中一个。用户进程陷入内核态的方法只有一种——调用系统调用。在陷入内核态之后，虽然进程本身处于睡眠等待的状态，但由于内核是代表进程在内核态执行任务，此时的进程上下文依然有效，即current宏可以被访问。但是需要注意的是，中断处理程序并不包含进程上下文，即使它是在用户进程运行过程中被触发的。

## 进程的终结

进程在结束退出时需要完成一系列繁琐复杂的工作，我们着重讨论两个方面：子进程的僵死状态和孤儿进程。

### 子进程的僵死

进程在退出时，最终会调用`do_exit()`系统调用，这个系统调用永不返回。当执行到这一段代码时，该进程永远不会被调度，但也永远不会退出。此时的进程处于EXIT_ZOMBIE状态，也就是我们常说的僵死状态。处于这一状态的进程，其几乎所有相关的资源已经被全部释放（或解除绑定），它唯一的作用就是等待父进程调用`wait`函数来收集其信息。一旦调用成功，该进程将彻底终结。

### 孤儿进程

子进程的退出善后工作将由父进程接手，那如果父进程先于子进程退出，会发生什么呢？Linux内核对此早有准备。对于父进程已经死亡的孤儿进程，内核将会采取以下几个措施：

1. 首先在父进程所属的线程组中寻找养父进程；
2. 如果失败，则将init进程作为父进程

这样保证了所有的进程都不会在退出后永远处于僵死状态而产生资源的浪费——init进程会不断调用`wait`函数来清除僵死进程。